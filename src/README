user: lmartel
user: andymo

We solved assignment 3 by using our existing assignment 2 code. 

Part 1
======

Our assignment 2 code already used exceptions in most situations to record errors. We were
catching them at the Rep layer and printing error messages. We moved the logging to where
the exceptions were thrown and stopped catching the exceptions.

We have defined a few general exception types that encapsulate the kinds of errors that can
occur in the system. They are found in Error.h

Part 2
======

We wrote an activity manager. It is based mostly on the implementation that was shown in 
the example. We made a few changes to the flow and to the information it tracks. When 
an activity is created, it is created in the "waiting" state. Also, we do not track
names of activities. We do not need them in our code because wherever we need to 
change an activity we have a reference to it.

Furthermore, we made the ActivityManager a subordinate of the engine. We added an
ActivityManagerRep to the rep layer and time is controlled with this. It is kind of strange
but we do not think it is any stranger than having an instance for Conn.

Part 3
======

We implemented a shipment class and several reactors. The shipment is responsible for knowing
its route and various statistics about itself.

The reactors are:

InjectionActivityReactor -- responsible for adding shipments to customer nodes.
ForwardingActivityReactor -- responsible for switching shipments onto segments from locations
TransferActivityReactor -- responsible for transferring a single shipment along a segment.

These activity reactors and their associated activities are created and controlled by reactors
that listen to attributes of segments and locations.

Routing
-------
We preprocess the network at the start of the simulation (the first time the client sets the `now`
attribute through the activityManagerRep) to generate routing tables. We run a Connect query between
every pair A,B of nodes and record all possible routes from node A to node B. This increases simulation
startup time but speeds up building the network and running the simulation, which we thought was a
reasonable tradeoff.

Part 4
======

We implemented the realtime activity manager by adding optional `step` and `speed` attributes
to the activity manager. `step` is the maximum number of hours forward through time the manager
is allowed to move before logging its progress (though it will stop earlier if an activity needs
to execute). `step` = 0 signifies virtual time, and `step` > 0 turns on realtime simulation.
The `speed` attribute sets the number of virtual hours that should pass per wall-clock second.

Part 5
======



==============================================================================================

Assignment 2 README:

There is a full unit test suite provided in unit-tests.

Our example program is UnitedStatesCities

As required by the assignment description we split our code into two parts: the rep layer and 
the engine layer. 

The rep layer expands only slightly on the heirarchy that was present in 
the starter code: we force every Rep to descend from InstanceImpl in order to give us the 
ability to add a little bit of housekeeping information in. For each class of entity
there is a corresponding Rep class. LocationRep, SegmentRep, etc. Each of these maintains
a reference to the InstanceManager that created it. The reps all access the engine through
the reference thta the InstanceManager holds.

The Engine layer is more complicated. We have two "classes" of class in our engine layer.
There are "Entitys" which are as described in the class. Entity objects inherit from 
PtrInterface and are required to have a name. There are also "Ordinal" types which 
inherit from the given Ordinal class. These types are unnamed and are never used with
pointers. Each ordinal type implements a "string" operator that is appropriate to its type
and also has a constructor which limits them to valid values.

There are several kinds of entities. In our system we have:

* fleet
* location
** terminal
*** boat terminal
*** plane terminal
*** truck terminal
** customer
** port
* segment
* statistics
* connectivity

Each of these types of entities has its own class. 

Over all of these entities there is an Engine object. The engine is responsible for holding
references (indexed by name) to each of the entities in the simulation. It also holds all 
of the factory methods for creating entities and provides a Notifiee interface that allows
Statistics objects to listen to it.


Design decisions:
==========

We decided to store non-existent return segments and sources as "NULL" values in the corresponding
attributes. This leads to a few issues with null checking, and also makes it slightly
difficult to distinguish between an invalid name and an uninitialized property at the engine layer.
We deal with this by checking at the rep layer that all names that are used to assign "source"
and "return segment" are valid.

We also implemented the bookkeeping associated with returnSegments and deleting sources without
notifications. We felt that it was simpler for our use case.

Error handling:

We decided to handle errors by throwing exceptions at the engine layer. These exceptions bubble 
to the rep layer where they are caught by catch statements in #attribute and #attributeIs in 
the appropriate rep classes. At this point an error message is logged. The exception types
are generic but include specific messages as members. We did not choose to display 
the more detailed error messages although this is certainly a possibility.


Semantics:
========

We have implemented our collections according to Cheriton's semantics. In general they return "NULL"
for missing elements, and they never throw exceptions.

Our mutators are all exception-free (except for when invalid values are set.)
Our getters are all nilpotent.

Our notifications all implement synchronous processing as opposed to asynchronous processing.
There are a few instances where this assumption matters (mostly for statistics) but this would
be fixable.
